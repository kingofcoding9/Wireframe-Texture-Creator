<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Texture DNA Lab | 3D Preview</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js and OrbitControls -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        /* Base Styles */
        body { background-color: #0b0f19; color: #e2e8f0; font-family: 'Segoe UI', system-ui, sans-serif; overflow: hidden; }
        
        /* Scrollbar */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: #111827; }
        ::-webkit-scrollbar-thumb { background: #374151; border-radius: 3px; }
        
        /* Utility */
        .checkerboard {
            background-color: #1a1a1a;
            background-image:
              linear-gradient(45deg, #222 25%, transparent 25%),
              linear-gradient(-45deg, #222 25%, transparent 25%),
              linear-gradient(45deg, transparent 75%, #222 75%),
              linear-gradient(-45deg, transparent 75%, #222 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }

        .loader {
            border: 3px solid rgba(255,255,255,0.1);
            border-top: 3px solid #10b981;
            border-radius: 50%;
            width: 20px; height: 20px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Step Logic */
        .step-locked { opacity: 0.5; pointer-events: none; filter: grayscale(1); }
        .step-active { opacity: 1; pointer-events: auto; filter: grayscale(0); }

        /* Layer Tabs */
        .layer-tab { transition: all 0.2s; border-bottom: 2px solid transparent; opacity: 0.6; }
        .layer-tab.active { opacity: 1; border-color: #10b981; color: #10b981; }

        /* Search Result Modal */
        .search-item:hover { background-color: #1f2937; border-color: #10b981; }
        
        input[type=range] { -webkit-appearance: none; background: transparent; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 12px; width: 12px; border-radius: 50%; background: #10b981; cursor: pointer; margin-top: -4px; box-shadow: 0 0 5px rgba(16,185,129,0.5);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; cursor: pointer; background: #374151; border-radius: 2px;
        }
        
        optgroup { color: #10b981; font-weight: bold; background: #111827; }
        option { color: #e2e8f0; background: #1f2937; padding: 4px; }

        /* Sidebar Transition for Mobile */
        .sidebar { transition: transform 0.3s ease-in-out; }
        .sidebar-closed { transform: translateX(-100%); }
        @media (min-width: 768px) {
            .sidebar-closed { transform: none; }
        }
    </style>
</head>
<body class="h-screen flex flex-col text-sm">

    <div id="toast-container" class="fixed top-4 left-1/2 -translate-x-1/2 z-[60] flex flex-col gap-2 w-max max-w-[90vw] pointer-events-none"></div>
    <input type="file" id="fileInput" accept=".json,.txt" class="hidden" onchange="app.handleFileSelect(event)">
    <input type="color" id="manualColorPicker" class="opacity-0 absolute -z-10">
    <img id="refImg" class="hidden" crossorigin="anonymous">

    <!-- SEARCH RESULTS MODAL -->
    <div id="searchModal" class="fixed inset-0 bg-black/80 z-50 hidden flex items-center justify-center p-4 backdrop-blur-sm">
        <div class="bg-gray-900 border border-gray-700 rounded-lg shadow-2xl w-full max-w-md flex flex-col max-h-[80vh]">
            <div class="p-4 border-b border-gray-800 flex justify-between items-center">
                <div><h3 class="font-bold text-green-400">Texture Library</h3><p class="text-[10px] text-gray-500" id="searchMeta">Searching...</p></div>
                <button onclick="document.getElementById('searchModal').classList.add('hidden')" class="text-gray-500 hover:text-white">‚úï</button>
            </div>
            <div id="resultsList" class="flex-1 overflow-y-auto p-2 space-y-1 custom-scrollbar"></div>
        </div>
    </div>

    <!-- HEADER -->
    <header class="h-12 bg-gray-900 border-b border-gray-800 flex items-center justify-between px-4 shrink-0 z-20 relative">
        <div class="flex items-center gap-3">
            <!-- Mobile Menu Toggle -->
            <button onclick="app.toggleSidebar()" class="md:hidden text-gray-400 hover:text-white">
                <svg width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M4 6h16M4 12h16M4 18h16"></path></svg>
            </button>

            <div class="flex items-center gap-2">
                <div class="w-6 h-6 bg-gradient-to-br from-green-500 to-blue-600 rounded flex items-center justify-center font-bold text-white text-xs">T</div>
                <h1 class="font-bold text-gray-200 tracking-wide hidden sm:block">Texture DNA</h1>
            </div>
        </div>
        <div class="flex items-center gap-3">
            <select id="resSelect" onchange="app.updateResolution()" class="bg-gray-800 border border-gray-700 text-gray-300 text-xs rounded px-2 py-1 focus:outline-none">
                <option value="64">64px</option>
                <option value="128">128px</option>
                <option value="256">256px</option>
                <option value="512" selected>512px</option>
                <option value="1024">1024px</option>
            </select>
            <button onclick="location.reload()" class="text-xs text-gray-500 hover:text-white">Reset</button>
        </div>
    </header>

    <div class="main-layout flex-1 flex h-full overflow-hidden relative">
        
        <!-- SIDEBAR -->
        <div id="sidebar" class="sidebar sidebar-closed md:transform-none absolute md:relative z-30 w-[85vw] md:w-[340px] h-full bg-gray-900 border-r border-gray-800 flex flex-col shrink-0 overflow-y-auto custom-scrollbar shadow-2xl md:shadow-none">
            
            <!-- Mobile Close Button -->
            <div class="md:hidden p-2 flex justify-end border-b border-gray-800">
                <button onclick="app.toggleSidebar()" class="text-gray-400 hover:text-white px-2 py-1 text-xs uppercase font-bold">Close Menu</button>
            </div>

            <!-- 1. Geometry -->
            <div class="p-4 border-b border-gray-800">
                <div class="flex justify-between items-center mb-2">
                    <label class="font-bold text-blue-400 text-xs uppercase">1. Geometry</label>
                    <span id="modelStatus" class="text-[10px] text-gray-500 bg-gray-800 px-1.5 py-0.5 rounded border border-gray-700">None</span>
                </div>
                <div onclick="document.getElementById('fileInput').click()" 
                     class="border border-dashed border-gray-600 bg-gray-800/40 hover:bg-gray-800 hover:border-blue-400 transition-all rounded p-4 cursor-pointer text-center group">
                    <p id="fileName" class="text-xs text-gray-400 group-hover:text-blue-300 font-medium">Click to Upload .geo.json</p>
                </div>
            </div>

            <!-- 2. Synthesis -->
            <div id="step2" class="p-4 border-b border-gray-800 step-locked flex-1">
                <div class="flex justify-between items-center mb-2">
                    <label class="font-bold text-green-400 text-xs uppercase">2. Synthesizer</label>
                    <button onclick="app.randomizeParams()" class="text-xs text-gray-500 hover:text-green-400" title="Randomize Current Layer">üé≤ Remix Layer</button>
                </div>

                <!-- Layer Switcher -->
                <div class="flex border-b border-gray-700 mb-4">
                    <button onclick="app.setLayer(0)" id="tab-0" class="layer-tab active flex-1 py-2 text-xs font-bold text-center hover:bg-gray-800">Background</button>
                    <button onclick="app.setLayer(1)" id="tab-1" class="layer-tab flex-1 py-2 text-xs font-bold text-center hover:bg-gray-800">Foreground</button>
                </div>

                <!-- Engine Controls -->
                <div class="bg-black/20 rounded border border-gray-700 p-3 mb-4 space-y-3 relative">
                    
                    <!-- Preset Selector -->
                    <div>
                        <div class="flex justify-between mb-1">
                            <span class="text-[10px] text-gray-400 uppercase">Layer Preset</span>
                        </div>
                        <select id="presetSelector" onchange="app.applyPreset(this.value)" class="w-full bg-gray-800 border border-gray-600 text-xs text-white rounded px-2 py-1.5 cursor-pointer focus:border-green-500 focus:outline-none">
                            <option value="" disabled selected>Choose Material...</option>
                        </select>
                    </div>

                    <!-- Palette & DNA -->
                    <div>
                        <div class="flex justify-between text-[10px] text-gray-400 mb-1">
                            <span>Palette</span>
                            <button onclick="app.searchReference()" class="text-[10px] text-blue-400 hover:text-blue-300">üîç Search Ref</button>
                        </div>
                        <div class="grid grid-cols-6 gap-0.5 h-6 rounded overflow-hidden border border-gray-700" id="paletteBox"></div>
                    </div>

                    <!-- Search Source -->
                    <div class="mb-2">
                        <div class="flex gap-1">
                            <input id="searchQuery" type="text" placeholder="Ref Search (e.g. 'oak', 'stone')" 
                                   class="flex-1 bg-gray-800 border border-gray-700 rounded px-2 py-1.5 text-xs text-white focus:border-green-500 focus:outline-none"
                                   onkeypress="if(event.key==='Enter') app.searchReference()">
                            <button onclick="app.searchReference()" class="bg-gray-700 hover:bg-gray-600 text-white px-2.5 rounded text-xs">üîç</button>
                        </div>
                    </div>

                    <!-- Sliders -->
                    <div class="space-y-3 pt-2 border-t border-gray-700/50">
                        
                        <div class="grid grid-cols-2 gap-x-4 gap-y-2">
                            <div>
                                <div class="flex justify-between mb-1"><span class="text-[10px] text-gray-400">Scale</span><span id="val-scale" class="text-[9px] text-green-400">50</span></div>
                                <input type="range" id="scaleLevel" min="1" max="100" value="50" class="w-full h-1" oninput="app.updateUIVal('scale', this.value)">
                            </div>
                            <div>
                                <div class="flex justify-between mb-1"><span class="text-[10px] text-gray-400">Chaos</span><span id="val-chaos" class="text-[9px] text-green-400">20</span></div>
                                <input type="range" id="chaosLevel" min="0" max="100" value="20" class="w-full h-1" oninput="app.updateUIVal('chaos', this.value)">
                            </div>
                            <div>
                                <div class="flex justify-between mb-1"><span class="text-[10px] text-gray-400">Roughness</span><span id="val-noise" class="text-[9px] text-green-400">30</span></div>
                                <input type="range" id="noiseLevel" min="0" max="100" value="30" class="w-full h-1" oninput="app.updateUIVal('noise', this.value)">
                            </div>
                            <div>
                                <div class="flex justify-between mb-1"><span class="text-[10px] text-gray-400">Contrast</span><span id="val-contrast" class="text-[9px] text-green-400">50</span></div>
                                <input type="range" id="contrastLevel" min="0" max="100" value="50" class="w-full h-1" oninput="app.updateUIVal('contrast', this.value)">
                            </div>
                        </div>

                        <div>
                            <div class="flex justify-between mb-1"><span class="text-[10px] text-gray-400">Saturation</span><span id="val-sat" class="text-[9px] text-blue-400">100%</span></div>
                            <input type="range" id="satLevel" min="0" max="200" value="100" class="w-full h-1 accent-blue-500" oninput="app.updateUIVal('sat', this.value)">
                        </div>

                        <!-- FOREGROUND ONLY: Opacity -->
                        <div id="opacityControl" class="hidden border-t border-gray-700 pt-2">
                            <div class="flex justify-between mb-1"><span class="text-[10px] text-yellow-400 font-bold">Layer Opacity</span><span id="val-opacity" class="text-[9px] text-yellow-400">50%</span></div>
                            <input type="range" id="opacityLevel" min="0" max="100" value="50" class="w-full h-1 accent-yellow-500" oninput="app.updateUIVal('opacity', this.value)">
                        </div>

                    </div>
                </div>

                <button onclick="app.synthesize()" class="w-full py-2.5 bg-gradient-to-r from-green-600 to-emerald-600 hover:from-green-500 hover:to-emerald-500 text-white font-bold text-xs rounded shadow-lg shadow-green-900/20 transition-all flex items-center justify-center gap-2">
                    <span>Generate Composite</span>
                </button>
                
                <div class="mt-2 text-center">
                    <label class="text-[10px] text-gray-400 flex items-center justify-center gap-1 cursor-pointer">
                        <input type="checkbox" id="wireframeToggle" checked onchange="app.renderPreview()" class="accent-green-500"> Show UV Overlay
                    </label>
                </div>
            </div>

            <!-- 3. Export -->
            <div id="step3" class="p-4 step-locked">
                 <button onclick="app.export()" class="w-full py-2 bg-blue-600 hover:bg-blue-500 text-white font-bold text-xs rounded">
                    Download Assets
                </button>
            </div>
        </div>

        <!-- Overlay for Mobile Sidebar -->
        <div id="sidebarOverlay" onclick="app.toggleSidebar()" class="fixed inset-0 bg-black/50 z-20 hidden md:hidden backdrop-blur-sm"></div>

        <!-- CANVAS AREA -->
        <div class="canvas-area flex-1 bg-[#050505] relative flex flex-col min-w-0 overflow-hidden">
            
            <!-- View Mode Toggles -->
            <div class="absolute top-4 left-1/2 -translate-x-1/2 z-20 bg-gray-900 border border-gray-700 rounded-full p-1 flex shadow-xl">
                <button onclick="app.setViewMode('2d')" id="btn-2d" class="px-3 py-1 text-xs font-bold rounded-full bg-green-600 text-white transition-all">2D Map</button>
                <button onclick="app.setViewMode('3d')" id="btn-3d" class="px-3 py-1 text-xs font-bold rounded-full text-gray-400 hover:text-white transition-all">3D Model</button>
            </div>

            <!-- 2D Viewport -->
            <div id="view-2d" class="w-full h-full relative">
                <div id="canvasWrapper" class="absolute inset-0 checkerboard flex items-center justify-center cursor-grab touch-none">
                    <canvas id="mainCanvas" class="shadow-2xl"></canvas>
                </div>
                <!-- 2D Only Controls -->
                <div class="absolute bottom-4 right-4 flex gap-2 z-20">
                    <button onclick="app.fitView()" class="bg-gray-800/80 hover:bg-gray-700 text-white p-2 rounded backdrop-blur border border-gray-600 shadow-lg" title="Reset View">
                        <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"></path></svg>
                    </button>
                </div>
            </div>

            <!-- 3D Viewport -->
            <div id="view-3d" class="w-full h-full relative hidden bg-[#0b0f19]">
                <div id="three-container" class="w-full h-full cursor-move touch-none outline-none"></div>
                
                <!-- 3D Controls Overlay -->
                <div class="absolute bottom-4 left-4 right-4 flex justify-between items-end pointer-events-none">
                    <div class="text-[10px] text-gray-500 bg-gray-900/50 px-2 py-1 rounded backdrop-blur">
                        Left: Rotate ‚Ä¢ Right: Pan ‚Ä¢ Scroll: Zoom
                    </div>
                    <div class="flex gap-2 pointer-events-auto">
                        <button onclick="Viewer3D.toggleAutoRotate()" class="bg-gray-800/80 hover:bg-gray-700 text-white px-3 py-1.5 rounded backdrop-blur border border-gray-600 shadow-lg text-xs font-bold">
                            Spin
                        </button>
                         <button onclick="Viewer3D.resetCamera()" class="bg-gray-800/80 hover:bg-gray-700 text-white px-3 py-1.5 rounded backdrop-blur border border-gray-600 shadow-lg text-xs font-bold">
                            Reset Cam
                        </button>
                    </div>
                </div>
            </div>

            <div id="viewportMsg" class="absolute inset-0 flex flex-col items-center justify-center text-gray-600 pointer-events-none z-10 bg-black/50 backdrop-blur-sm transition-opacity duration-300">
                <p class="text-sm font-medium text-gray-300">Workspace Empty</p>
                <p class="text-xs mt-1 opacity-60">Upload .geo.json to begin</p>
            </div>
            
            <div id="loader" class="absolute inset-0 bg-black/80 z-50 hidden flex-col items-center justify-center backdrop-blur-sm">
                <div class="loader mb-2"></div>
                <p id="loaderText" class="text-green-400 text-[10px] font-mono uppercase animate-pulse">Processing...</p>
            </div>
        </div>
    </div>

    <script>
        const PRESETS = {
            "Woods": { "Oak Planks":{type:"wood",scale:0.5,chaos:0.1,noise:0.2,contrast:0.5,sat:1.0}, "Spruce":{type:"wood",scale:0.6,chaos:0.05,noise:0.15,contrast:0.4,sat:0.9}, "Birch":{type:"wood",scale:0.5,chaos:0.05,noise:0.1,contrast:0.3,sat:0.95}, "Jungle":{type:"wood",scale:0.4,chaos:0.2,noise:0.4,contrast:0.6,sat:1.1}, "Dark Oak":{type:"wood",scale:0.6,chaos:0.05,noise:0.15,contrast:0.6,sat:0.9}, "Rotting":{type:"wood",scale:0.5,chaos:0.6,noise:0.8,contrast:0.7,sat:0.7} },
            "Stones": { "Cobble":{type:"stone",scale:0.4,chaos:0.6,noise:0.5,contrast:0.7,sat:0.8}, "Smooth":{type:"stone",scale:0.2,chaos:0.1,noise:0.2,contrast:0.3,sat:0.9}, "Granite":{type:"stone",scale:0.7,chaos:0.8,noise:0.6,contrast:0.6,sat:1.1}, "Bedrock":{type:"stone",scale:0.8,chaos:0.9,noise:0.9,contrast:1.0,sat:0.8} },
            "Construction": { "Bricks":{type:"bricks",scale:0.5,chaos:0.1,noise:0.3,contrast:0.6,sat:1.1}, "Stone Brick":{type:"bricks",scale:0.4,chaos:0.05,noise:0.2,contrast:0.5,sat:0.9}, "Tiles":{type:"bricks",scale:0.8,chaos:0.0,noise:0.1,contrast:0.5,sat:1.0}, "Ruined":{type:"bricks",scale:0.5,chaos:0.7,noise:0.9,contrast:0.7,sat:0.7} },
            "Metals": { "Iron":{type:"metal",scale:0.3,chaos:0.1,noise:0.2,contrast:0.4,sat:0.8}, "Gold":{type:"metal",scale:0.3,chaos:0.1,noise:0.15,contrast:0.6,sat:1.2}, "Rust":{type:"metal",scale:0.6,chaos:0.7,noise:0.8,contrast:0.8,sat:1.1}, "Chrome":{type:"metal",scale:0.1,chaos:0.0,noise:0.05,contrast:0.9,sat:0.0} },
            "Organics": { "Scales":{type:"scales",scale:0.4,chaos:0.1,noise:0.3,contrast:0.7,sat:1.0}, "Alien":{type:"scales",scale:0.5,chaos:0.6,noise:0.5,contrast:0.4,sat:1.3}, "Dirt":{type:"stone",scale:1.0,chaos:0.8,noise:0.8,contrast:0.3,sat:0.9} },
            "Fabrics": { "Wool":{type:"weave",scale:0.8,chaos:0.1,noise:0.4,contrast:0.3,sat:1.0}, "Kevlar":{type:"weave",scale:0.65,chaos:0.05,noise:0.2,contrast:0.6,sat:1.0}, "Carbon":{type:"weave",scale:0.6,chaos:0.0,noise:0.1,contrast:0.8,sat:0.5} }
        };

        const TextureEngine = {
            adjustSat(r, g, b, sat) {
                const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                const s = sat;
                return [Math.min(255,Math.max(0,gray+(r-gray)*s)), Math.min(255,Math.max(0,gray+(g-gray)*s)), Math.min(255,Math.max(0,gray+(b-gray)*s))];
            },
            parseColor(hexOrRgb) {
                if(hexOrRgb.startsWith('#')) return [(parseInt(hexOrRgb.slice(1),16)>>16)&255, (parseInt(hexOrRgb.slice(1),16)>>8)&255, parseInt(hexOrRgb.slice(1),16)&255];
                return hexOrRgb.match(/\d+/g).map(Number);
            },
            analyze(imgElement) {
                const cvs = document.createElement('canvas'); cvs.width=64; cvs.height=64;
                const ctx = cvs.getContext('2d'); ctx.drawImage(imgElement,0,0,64,64);
                const data = ctx.getImageData(0,0,64,64).data;
                const colors = {}; let edges = 0;
                for(let i=0;i<data.length;i+=4) {
                    if(data[i+3]<128) continue;
                    const k=`${Math.round(data[i]/10)*10},${Math.round(data[i+1]/10)*10},${Math.round(data[i+2]/10)*10}`;
                    colors[k]=(colors[k]||0)+1;
                    if(i<data.length-4) { const l1=(data[i]+data[i+1]+data[i+2])/3, l2=(data[i+4]+data[i+5]+data[i+6])/3; if(Math.abs(l1-l2)>20) edges++; }
                }
                const sorted = Object.keys(colors).sort((a,b)=>colors[b]-colors[a]).slice(0,10).sort((a,b)=>{ const [r1,g1,b1]=a.split(',').map(Number), [r2,g2,b2]=b.split(',').map(Number); return (r1+g1+b1)-(r2+g2+b2);});
                const palette = []; for(let i=0;i<6;i++) { const c=sorted[Math.floor(i*(sorted.length/6))]||sorted[0]; if(c) palette.push(`rgb(${c})`); }
                return { palette, edgeRatio: edges/(64*64) };
            },
            render(ctx, x, y, w, h, config, isOverlay) {
                ctx.save(); ctx.beginPath(); ctx.rect(x, y, w, h); ctx.clip(); ctx.translate(x, y);
                const { type, palette, scale, chaos, noise, contrast, sat, opacity } = config;
                const p = palette.map(c => { const [r,g,b]=this.parseColor(c); const [nr,ng,nb]=this.adjustSat(r,g,b,sat); return `rgb(${Math.floor(nr)},${Math.floor(ng)},${Math.floor(nb)})`; });
                
                if (isOverlay) ctx.globalAlpha = opacity / 100;

                // Base Fill
                if (!isOverlay || (isOverlay && chaos < 0.5)) { 
                    ctx.fillStyle = p[2]; ctx.fillRect(0, 0, w, h);
                }

                // Generator Routing
                if (type === 'wood') this.genWood(ctx, w, h, p, scale, chaos, contrast);
                else if (type === 'bricks') this.genBricks(ctx, w, h, p, scale, chaos, contrast);
                else if (type === 'scales') this.genCells(ctx, w, h, p, scale, chaos, contrast);
                else if (type === 'metal') this.genMetal(ctx, w, h, p, scale, chaos, contrast);
                else if (type === 'weave') this.genWeave(ctx, w, h, p, scale, chaos, contrast);
                else this.genNoise(ctx, w, h, p, scale, chaos, contrast); 

                // Finish
                if (noise > 0.05) this.genGrain(ctx, w, h, noise);
                if (chaos > 0.2) this.genGrunge(ctx, w, h, noise * 0.5 + chaos * 0.2);

                ctx.restore();
            },

            // --- PRECISE GENERATORS ---
            genWood(ctx, w, h, p, scale, chaos, contrast) {
                const isHorz = w >= h;
                const plankCount = Math.max(2, Math.floor(2 + scale * 6)); 
                const plankSize = (isHorz ? h : w) / plankCount;
                for (let i = 0; i < plankCount; i++) {
                    const pos = i * plankSize;
                    ctx.fillStyle = (i % 2 === 0) ? p[2] : p[3];
                    if (isHorz) ctx.fillRect(0, pos, w, plankSize);
                    else ctx.fillRect(pos, 0, plankSize, h);
                    ctx.fillStyle = p[1];
                    ctx.globalAlpha = 0.1 + (contrast * 0.2);
                    const grainDensity = Math.floor(plankSize * 0.5);
                    for (let g = 0; g < grainDensity; g++) {
                        const gPos = pos + (Math.random() * plankSize);
                        const len = (isHorz ? w : h) * (0.2 + Math.random() * 0.8);
                        const start = Math.random() * ((isHorz ? w : h) - len);
                        const wiggle = (Math.random() - 0.5) * (chaos * 4);
                        if (isHorz) ctx.fillRect(start, gPos + wiggle, len, 1);
                        else ctx.fillRect(gPos + wiggle, start, 1, len);
                    }
                    ctx.globalAlpha = 1.0;
                    if (i > 0) {
                        ctx.fillStyle = p[0];
                        ctx.globalAlpha = 0.6 + (contrast * 0.4);
                        if (isHorz) ctx.fillRect(0, pos, w, 1);
                        else ctx.fillRect(pos, 0, 1, h);
                        ctx.globalAlpha = 1.0;
                    }
                }
            },
            genBricks(ctx, w, h, p, scale, chaos, contrast) {
                ctx.fillStyle = p[0]; ctx.fillRect(0,0,w,h);
                const rows = Math.max(2, Math.floor(2 + scale * 8));
                const cols = Math.max(2, Math.floor(2 + scale * 4));
                const bH = h / rows; const bW = w / cols;
                const gap = Math.max(1, Math.floor(Math.min(w,h) * 0.02));
                for (let r = 0; r < rows; r++) {
                    const offset = (r % 2) * (bW / 2);
                    for (let c = -1; c <= cols; c++) {
                        if (chaos > 0.5 && Math.random() < (chaos - 0.5) * 0.2) continue;
                        const rnd = Math.random();
                        if (rnd > 0.9 - (contrast * 0.2)) ctx.fillStyle = p[4];
                        else if (rnd > 0.4) ctx.fillStyle = p[3];
                        else ctx.fillStyle = p[2];
                        const jx = (Math.random() - 0.5) * (chaos * gap * 2);
                        ctx.fillRect((c * bW) + offset + gap + jx, (r * bH) + gap, Math.max(1, bW - gap*2), Math.max(1, bH - gap*2));
                    }
                }
            },
            genWeave(ctx, w, h, p, scale, chaos, contrast) {
                const thread = Math.max(2, Math.floor(12 - (scale * 10)));
                const cols = Math.ceil(w / thread); const rows = Math.ceil(h / thread);
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        const isVert = (r + c) % 2 === 0;
                        ctx.fillStyle = isVert ? p[2] : p[3];
                        if (Math.random() > 0.95) ctx.fillStyle = p[4];
                        ctx.fillRect(c*thread, r*thread, thread, thread);
                        ctx.fillStyle = '#000'; ctx.globalAlpha = 0.3 * contrast;
                        if (isVert) { ctx.fillRect(c*thread, r*thread, 1, thread); ctx.fillRect((c+1)*thread - 1, r*thread, 1, thread); } 
                        else { ctx.fillRect(c*thread, r*thread, thread, 1); ctx.fillRect(c*thread, (r+1)*thread - 1, thread, 1); }
                        ctx.globalAlpha = 1.0;
                    }
                }
            },
            genCells(ctx, w, h, p, scale, chaos, contrast) {
                const cellS = Math.max(4, Math.floor(32 - (scale * 24)));
                for (let y = 0; y < h; y += cellS) {
                    for (let x = 0; x < w; x += cellS) {
                        ctx.fillStyle = (Math.random() > 0.5) ? p[3] : p[2];
                        const jx = (Math.random()-0.5) * (chaos * cellS);
                        const jy = (Math.random()-0.5) * (chaos * cellS);
                        const size = Math.max(2, cellS - 1);
                        ctx.fillRect(x + jx, y + jy, size, size);
                        if (contrast > 0.5) {
                            ctx.fillStyle = p[4]; ctx.globalAlpha = 0.3;
                            ctx.fillRect(x + jx + size/4, y + jy + size/4, size/2, size/2); ctx.globalAlpha = 1.0;
                        }
                    }
                }
            },
            genMetal(ctx, w, h, p, scale, chaos, contrast) {
                const grad = ctx.createLinearGradient(0,0,w,h); grad.addColorStop(0,p[2]); grad.addColorStop(1,p[4]); 
                ctx.fillStyle=grad; ctx.fillRect(0,0,w,h);
                ctx.strokeStyle=p[5]; ctx.globalAlpha=0.2 * contrast;
                const count = 5 + (chaos * 20);
                ctx.beginPath();
                for(let i=0; i<count; i++) {
                    const sx=Math.random()*w, sy=Math.random()*h;
                    const len=(w*0.2) * (1 + Math.random());
                    ctx.moveTo(sx,sy); ctx.lineTo(sx+len, sy+len);
                }
                ctx.stroke(); ctx.globalAlpha=1.0;
            },
            genNoise(ctx, w, h, p, scale, chaos, contrast) {
                const count = (w*h) * 0.1 * scale;
                for(let i=0; i<count; i++) {
                    ctx.fillStyle = (Math.random()>0.5) ? p[1] : p[3];
                    ctx.globalAlpha = 0.3 * contrast;
                    const s = 1 + Math.random() * (scale * 4);
                    ctx.fillRect(Math.random()*w, Math.random()*h, s, s);
                }
                ctx.globalAlpha=1.0;
            },
            genGrain(ctx, w, h, amt) {
                ctx.fillStyle = '#000'; ctx.globalAlpha = amt * 0.15;
                const count = w*h*0.5;
                for(let i=0; i<count; i++) ctx.fillRect(Math.random()*w, Math.random()*h, 1, 1);
                ctx.globalAlpha = 1.0;
            },
            genGrunge(ctx, w, h, amt) {
                if(amt < 0.05) return;
                ctx.fillStyle = '#1a0f00'; ctx.globalAlpha = Math.min(0.8, amt);
                const blobs = 2 + (amt * 10);
                for(let i=0; i<blobs; i++) {
                    const s = Math.random() * (Math.min(w,h)/2);
                    if(s > 2) ctx.fillRect(Math.random()*w, Math.random()*h, s, s);
                }
                ctx.globalAlpha = 1.0;
            }
        };

        // --- THREE.JS WRAPPER ---
        const Viewer3D = {
            scene: null, camera: null, renderer: null, controls: null, modelGroup: null, 
            isInit: false, material: null,
            
            init(container) {
                if(this.isInit) return;
                const w = container.clientWidth, h = container.clientHeight;
                
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x0b0f19);

                // Lighting
                const ambient = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambient);
                const dir = new THREE.DirectionalLight(0xffffff, 0.8);
                dir.position.set(10, 20, 10);
                this.scene.add(dir);
                const back = new THREE.DirectionalLight(0xffffff, 0.3);
                back.position.set(-10, -10, -10);
                this.scene.add(back);

                // Camera
                this.camera = new THREE.PerspectiveCamera(45, w / h, 0.1, 1000);
                this.camera.position.set(20, 20, 20);

                // Renderer
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.renderer.setSize(w, h);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                container.appendChild(this.renderer.domElement);

                // Controls
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                this.controls.screenSpacePanning = true;

                // Material
                this.material = new THREE.MeshStandardMaterial({ 
                    side: THREE.DoubleSide, 
                    transparent: true,
                    alphaTest: 0.1
                });

                this.isInit = true;
                this.animate();
            },

            loadGeometry(geoData, textureCanvas, resolution) {
                if(!this.isInit || !geoData) return;
                if(this.modelGroup) this.scene.remove(this.modelGroup);
                this.modelGroup = new THREE.Group();

                // Texture
                const tex = new THREE.CanvasTexture(textureCanvas);
                tex.magFilter = THREE.NearestFilter;
                tex.minFilter = THREE.NearestFilter;
                tex.flipY = false;
                this.material.map = tex;
                this.material.map.needsUpdate = true;

                const geo = geoData["minecraft:geometry"][0];
                // UV FIX: Use the geometry's definition for UV math, NOT the high-res canvas size.
                const texW = geo.description.texture_width || 64;
                const texH = geo.description.texture_height || 64;
                
                const bounds = new THREE.Box3();

                geo.bones?.forEach(bone => {
                    if(!bone.cubes) return;
                    const group = new THREE.Group();
                    
                    if (bone.pivot) {
                        group.position.set(bone.pivot[0], bone.pivot[1], bone.pivot[2]);
                    }

                    bone.cubes.forEach(cube => {
                        const [w, h, d] = cube.size;
                        const [x, y, z] = cube.origin;
                        
                        const geometry = new THREE.BoxGeometry(w, h, d);
                        const uvs = geometry.attributes.uv;

                        const mapFace = (faceIdx, u, v, uw, uh) => {
                            const i = faceIdx * 4;
                            const x1 = u / texW; 
                            const y1 = v / texH;
                            const x2 = (u + uw) / texW;
                            const y2 = (v + uh) / texH;
                            
                            uvs.setXY(i, x2, y1);   // Top Right
                            uvs.setXY(i+1, x1, y1); // Top Left
                            uvs.setXY(i+2, x2, y2); // Bottom Right
                            uvs.setXY(i+3, x1, y2); // Bottom Left
                        };

                        if (Array.isArray(cube.uv)) {
                            const [u, v] = cube.uv;
                            mapFace(0, u, v + d, d, h);                 // Right
                            mapFace(1, u + d + w, v + d, d, h);         // Left
                            mapFace(2, u + d, v, w, d);                 // Top
                            mapFace(3, u + d + w, v, w, d);             // Bottom
                            mapFace(5, u + d, v + d, w, h);             // Back (North)
                            mapFace(4, u + d + w + d, v + d, w, h);     // Front (South)
                        } else if (typeof cube.uv === 'object') {
                            // Per-face UV mapping (Advanced)
                            const mapSide = (faceIdx, uvDef) => {
                                if(!uvDef || !uvDef.uv || !uvDef.uv_size) return;
                                mapFace(faceIdx, uvDef.uv[0], uvDef.uv[1], uvDef.uv_size[0], uvDef.uv_size[1]);
                            };
                            mapSide(0, cube.uv.east);
                            mapSide(1, cube.uv.west);
                            mapSide(2, cube.uv.up);
                            mapSide(3, cube.uv.down);
                            mapSide(5, cube.uv.north);
                            mapSide(4, cube.uv.south);
                        }

                        const mesh = new THREE.Mesh(geometry, this.material);
                        let localX = x + w/2;
                        let localY = y + h/2;
                        let localZ = z + d/2;

                        if (bone.pivot) {
                            localX -= bone.pivot[0];
                            localY -= bone.pivot[1];
                            localZ -= bone.pivot[2];
                        }

                        mesh.position.set(localX, localY, localZ);
                        group.add(mesh);
                        
                        // World bounds calculation
                        const worldMesh = mesh.clone();
                        worldMesh.position.set(x + w/2, y + h/2, z + d/2);
                        bounds.expandByObject(worldMesh);
                    });
                    this.modelGroup.add(group);
                });

                // Auto-Center
                const center = new THREE.Vector3();
                bounds.getCenter(center);
                this.modelGroup.position.sub(center);
                this.scene.add(this.modelGroup);
                
                // Adjust camera distance
                const size = new THREE.Vector3();
                bounds.getSize(size);
                const maxDim = Math.max(size.x, size.y, size.z) || 10;
                this.camera.position.set(maxDim*1.5, maxDim*1.5, maxDim*1.5);
                this.controls.target.set(0,0,0);
                this.controls.update();
            },

            updateTexture(canvas) {
                if(this.material && this.material.map) {
                    this.material.map.image = canvas;
                    this.material.map.needsUpdate = true;
                }
            },

            resize(w, h) {
                if(!this.camera || !this.renderer) return;
                this.camera.aspect = w / h;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(w, h);
            },

            toggleAutoRotate() {
                this.controls.autoRotate = !this.controls.autoRotate;
            },

            resetCamera() {
                this.controls.reset();
                this.controls.autoRotate = false;
            },

            animate() {
                requestAnimationFrame(() => this.animate());
                if(this.controls) this.controls.update();
                if(this.renderer && this.scene) this.renderer.render(this.scene, this.camera);
            }
        };

        const App = {
            state: {
                model: null,
                texture: null,
                res: 512,
                layers: [
                    { type:'wood', palette:['#3e2723','#4e342e','#5d4037','#6d4c41','#795548','#8d6e63'], scale:0.5, chaos:0.1, noise:0.2, contrast:0.5, sat:1 },
                    { type:'stone', palette:['#000000','#1a1a1a','#333333','#4d4d4d','#666666','#808080'], scale:0.8, chaos:0.5, noise:0.5, contrast:0.5, sat:1, opacity:50 }
                ],
                activeLayer: 0,
                view: { x: 0, y: 0, scale: 1, dragging: false, lx: 0, ly: 0 },
                viewMode: '2d', // '2d' or '3d'
                sidebarOpen: false
            },
            els: {},

            init() {
                const ids = ['fileInput','fileName','step2','step3','canvasWrapper','mainCanvas','viewportMsg',
                             'loader','loaderText','resSelect','presetSelector','paletteBox','manualColorPicker',
                             'searchQuery','refImg','noiseLevel','contrastLevel','scaleLevel','chaosLevel','satLevel','opacityLevel','opacityControl',
                             'wireframeToggle','toast-container','searchModal','resultsList','sidebar','sidebarOverlay','view-2d','view-3d','btn-2d','btn-3d','three-container'];
                ids.forEach(id => this.els[id] = document.getElementById(id));

                this.ctx = this.els.mainCanvas.getContext('2d');
                this.initPresets();
                this.setLayer(0);
                this.setupCanvasEvents();
                
                this.els.manualColorPicker.addEventListener('input', (e) => {
                    if(this.state.activeColorIdx > -1) {
                        this.state.layers[this.state.activeLayer].palette[this.state.activeColorIdx] = e.target.value;
                        this.renderPalette();
                        if(this.state.texture) this.synthesize(true);
                    }
                });
                
                window.addEventListener('resize', () => { 
                    if(this.state.texture) this.fitView();
                    if(this.state.viewMode === '3d') Viewer3D.resize(this.els['view-3d'].clientWidth, this.els['view-3d'].clientHeight);
                });
            },

            // --- UI LOGIC ---
            toggleSidebar() {
                this.state.sidebarOpen = !this.state.sidebarOpen;
                const sb = this.els.sidebar;
                const ol = this.els.sidebarOverlay;
                
                if(this.state.sidebarOpen) {
                    sb.classList.remove('sidebar-closed');
                    ol.classList.remove('hidden');
                } else {
                    sb.classList.add('sidebar-closed');
                    ol.classList.add('hidden');
                }
            },

            setViewMode(mode) {
                this.state.viewMode = mode;
                if(mode === '2d') {
                    this.els['view-2d'].classList.remove('hidden');
                    this.els['view-3d'].classList.add('hidden');
                    this.els['btn-2d'].className = "px-3 py-1 text-xs font-bold rounded-full bg-green-600 text-white transition-all";
                    this.els['btn-3d'].className = "px-3 py-1 text-xs font-bold rounded-full text-gray-400 hover:text-white transition-all";
                } else {
                    this.els['view-2d'].classList.add('hidden');
                    this.els['view-3d'].classList.remove('hidden');
                    this.els['btn-2d'].className = "px-3 py-1 text-xs font-bold rounded-full text-gray-400 hover:text-white transition-all";
                    this.els['btn-3d'].className = "px-3 py-1 text-xs font-bold rounded-full bg-blue-600 text-white transition-all";
                    
                    Viewer3D.init(this.els['three-container']);
                    Viewer3D.resize(this.els['view-3d'].clientWidth, this.els['view-3d'].clientHeight);
                    if(this.state.model && this.state.texture) Viewer3D.updateTexture(this.els.mainCanvas);
                }
            },

            initPresets() {
                const sel = this.els.presetSelector;
                sel.innerHTML = '<option value="" disabled selected>Choose Material...</option>';
                for (const [category, items] of Object.entries(PRESETS)) {
                    const group = document.createElement('optgroup'); group.label = category;
                    for (const name of Object.keys(items)) {
                        const opt = document.createElement('option'); opt.value = `${category}:${name}`; opt.innerText = name; group.appendChild(opt);
                    }
                    sel.appendChild(group);
                }
            },

            setLayer(idx) {
                this.state.activeLayer = idx;
                document.getElementById('tab-0').className = `layer-tab flex-1 py-2 text-xs font-bold text-center hover:bg-gray-800 ${idx===0?'active':''}`;
                document.getElementById('tab-1').className = `layer-tab flex-1 py-2 text-xs font-bold text-center hover:bg-gray-800 ${idx===1?'active':''}`;
                
                const l = this.state.layers[idx];
                this.els.scaleLevel.value = l.scale * 100;
                this.els.chaosLevel.value = l.chaos * 100;
                this.els.noiseLevel.value = l.noise * 100;
                this.els.contrastLevel.value = l.contrast * 100;
                this.els.satLevel.value = l.sat * 100;
                if(idx===1) {
                    this.els.opacityLevel.value = l.opacity;
                    this.els.opacityControl.classList.remove('hidden');
                } else {
                    this.els.opacityControl.classList.add('hidden');
                }
                
                ['scale','chaos','noise','contrast','sat'].forEach(k => this.updateUINum(k, l[k]*100));
                if(idx===1) this.updateUINum('opacity', l.opacity);
                this.renderPalette();
            },

            updateUINum(k, v) {
                const el = document.getElementById(k==='noise'?'val-noise':k==='sat'?'val-sat':k==='opacity'?'val-opacity':`val-${k}`);
                if(el) el.innerText = (k==='sat'||k==='opacity') ? v+'%' : v;
            },

            updateUIVal(key, val) {
                const l = this.state.layers[this.state.activeLayer];
                if(key === 'opacity') l.opacity = parseInt(val);
                else l[key] = parseInt(val) / 100;
                this.updateUINum(key, val);
                if(this.state.texture) this.synthesize(true);
            },

            applyPreset(val) {
                const [cat, name] = val.split(':');
                const p = PRESETS[cat][name];
                const l = this.state.layers[this.state.activeLayer];
                l.type = p.type; l.scale = p.scale; l.chaos = p.chaos; l.noise = p.noise; l.contrast = p.contrast; l.sat = p.sat;
                this.setLayer(this.state.activeLayer); 
                if(this.state.texture) this.synthesize(true);
                this.notify(`Applied: ${name}`, "success");
            },

            randomizeParams() {
                const l = this.state.layers[this.state.activeLayer];
                l.scale = (Math.floor(Math.random() * 90) + 10)/100;
                l.chaos = (Math.floor(Math.random() * 60))/100;
                l.noise = (Math.floor(Math.random() * 50) + 10)/100;
                l.contrast = (Math.floor(Math.random() * 60) + 20)/100;
                l.sat = (Math.floor(Math.random() * 100) + 50)/100;
                this.setLayer(this.state.activeLayer);
                if(this.state.texture) this.synthesize(true);
                this.notify("Layer Remixed!", "success");
            },

            synthesize(silent = false) {
                if(!this.state.model) return this.notify("No model loaded", "error");
                if(!silent) this.setLoading(true, "Synthesizing...");

                requestAnimationFrame(() => {
                    try {
                        const size = this.state.res;
                        const cvs = document.createElement('canvas'); cvs.width = size; cvs.height = size;
                        const ctx = cvs.getContext('2d'); ctx.clearRect(0, 0, size, size);

                        const geo = this.state.model["minecraft:geometry"][0];
                        const scaleX = size / (geo.description.texture_width || 64);
                        const scaleY = size / (geo.description.texture_height || 64);

                        geo.bones?.forEach(bone => {
                            if(!bone.cubes) return;
                            bone.cubes.forEach(cube => {
                                if (Array.isArray(cube.uv)) {
                                    const [u, v] = cube.uv; const [w, h, d] = cube.size;
                                    const faces = [{ x: u+d, y: v+d, w: w, h: h }, { x: u+d+w+d, y: v+d, w: w, h: h }, { x: u, y: v+d, w: d, h: h }, { x: u+d+w, y: v+d, w: d, h: h }, { x: u+d, y: v, w: w, h: d }, { x: u+d+w, y: v, w: w, h: d }];
                                    faces.forEach(f => {
                                        const rx=Math.floor(f.x*scaleX), ry=Math.floor(f.y*scaleY), rw=Math.ceil(f.w*scaleX), rh=Math.ceil(f.h*scaleY);
                                        TextureEngine.render(ctx, rx, ry, rw, rh, this.state.layers[0], false); 
                                        if(this.state.layers[1].opacity > 0) TextureEngine.render(ctx, rx, ry, rw, rh, this.state.layers[1], true);
                                    });
                                } else if (typeof cube.uv === 'object') {
                                    Object.values(cube.uv).forEach(d => {
                                        if(d.uv && d.uv_size) {
                                            const rx=Math.floor(d.uv[0]*scaleX), ry=Math.floor(d.uv[1]*scaleY), rw=Math.ceil(d.uv_size[0]*scaleX), rh=Math.ceil(d.uv_size[1]*scaleY);
                                            TextureEngine.render(ctx, rx, ry, rw, rh, this.state.layers[0], false);
                                            if(this.state.layers[1].opacity > 0) TextureEngine.render(ctx, rx, ry, rw, rh, this.state.layers[1], true);
                                        }
                                    });
                                }
                            });
                        });

                        const img = new Image();
                        img.onload = () => {
                            this.state.texture = img;
                            this.renderPreview();
                            
                            if(this.state.viewMode === '3d' && Viewer3D.isInit) {
                                Viewer3D.updateTexture(cvs);
                            }

                            if(!silent) {
                                this.fitView();
                                this.setLoading(false);
                                this.els.step3.classList.remove('step-locked');
                                this.els.step3.classList.add('step-active');
                                this.notify("Texture Composite Generated", "success");
                                
                                if(this.els['three-container'].innerHTML === '') Viewer3D.init(this.els['three-container']);
                                Viewer3D.loadGeometry(this.state.model, cvs, size);
                            } else {
                                if(Viewer3D.isInit) Viewer3D.updateTexture(cvs);
                            }
                        };
                        img.src = cvs.toDataURL();
                    } catch(e) { console.error(e); this.setLoading(false); this.notify(e.message, "error"); }
                });
            },

            // --- DNA & Search ---
            async searchReference() {
                const input = document.getElementById('searchQuery');
                if(!input) return this.notify("Search unavailable", "error");
                const q = input.value.trim();
                if(!q) return this.notify("Enter query", "error");
                this.setLoading(true, "Scanning...");
                try {
                    const res = await fetch(`https://api.github.com/repos/kingofcoding9/Wireframe-Texture-Creator/git/trees/main?recursive=1`);
                    if(!res.ok) throw new Error("Repo Error");
                    const data = await res.json();
                    const matches = data.tree.filter(n => n.type==='blob' && n.path.match(/\.(png|jpg)$/i) && n.path.toLowerCase().includes(q.toLowerCase()));
                    if(!matches.length) throw new Error("No matches");
                    this.showResults(matches.map(n => ({ name: n.path.split('/').pop(), path: n.path, download_url: `https://raw.githubusercontent.com/kingofcoding9/Wireframe-Texture-Creator/main/${n.path}`, sha: n.sha })));
                    this.setLoading(false);
                } catch(e) { this.setLoading(false); this.notify(e.message, "error"); }
            },

            showResults(matches) {
                const list = this.els.resultsList; list.innerHTML = '';
                matches.slice(0, 50).forEach(file => {
                    const div = document.createElement('div');
                    div.className = "search-item p-3 bg-gray-800 border border-gray-700 rounded cursor-pointer transition-colors flex items-center gap-3 relative";
                    div.innerHTML = `
                        <div class="w-10 h-10 bg-gray-700 rounded flex items-center justify-center text-xs text-gray-500 overflow-hidden shrink-0"><div class="animate-pulse w-full h-full bg-gray-600"></div></div>
                        <div class="flex-1 min-w-0"><div class="text-xs text-gray-200 font-bold truncate">${file.name}</div><div class="flex gap-0.5 mt-1 h-2 w-full" id="palette-${file.sha}"></div></div>
                    `;
                    div.onclick = () => { this.els.searchModal.classList.add('hidden'); this.processImage(file.download_url, file.name); };
                    list.appendChild(div);
                    const img = new Image(); img.crossOrigin = "Anonymous"; img.src = file.download_url;
                    img.onload = () => {
                        const dna = TextureEngine.analyze(img);
                        const pal = document.getElementById(`palette-${file.sha}`);
                        if(pal) dna.palette.forEach(c => { const s=document.createElement('div'); s.className='flex-1 h-full rounded-sm'; s.style.backgroundColor=c; pal.appendChild(s); });
                        div.querySelector('.w-10').innerHTML = `<img src="${file.download_url}" class="w-full h-full object-cover">`;
                    };
                });
                document.getElementById('searchMeta').textContent = `Found ${matches.length} items`;
                this.els.searchModal.classList.remove('hidden');
            },

            processImage(url, name) {
                this.setLoading(true, "Analyzing DNA...");
                const img = this.els.refImg; img.crossOrigin = "Anonymous";
                img.onload = () => {
                    const dna = TextureEngine.analyze(img);
                    const l = this.state.layers[this.state.activeLayer];
                    l.palette = dna.palette;
                    this.renderPalette();
                    this.notify(`Palette loaded to Layer ${this.state.activeLayer+1}`, "success");
                    this.setLoading(false);
                    if(this.state.model) this.synthesize(true);
                };
                img.src = url;
            },

            renderPalette() {
                const box = this.els.paletteBox; box.innerHTML = '';
                const pal = this.state.layers[this.state.activeLayer].palette;
                pal.forEach((c,i) => {
                    const d = document.createElement('div'); d.className = 'w-full h-full cursor-pointer hover:opacity-80'; d.style.backgroundColor = c;
                    d.onclick = () => { this.state.activeColorIdx = i; this.els.manualColorPicker.click(); };
                    box.appendChild(d);
                });
            },

            handleFileSelect(e) {
                const f = e.target.files[0]; if(!f) return;
                const r = new FileReader();
                r.onload = (ev) => {
                    try {
                        this.state.model = JSON.parse(ev.target.result);
                        document.getElementById('fileName').textContent = f.name;
                        document.getElementById('modelStatus').textContent = "Loaded";
                        document.getElementById('modelStatus').className = "text-[10px] text-green-400 bg-green-900 px-1.5 py-0.5 rounded border border-green-700";
                        this.els.step2.classList.remove('step-locked');
                        this.els.step2.classList.add('step-active');
                        this.els.viewportMsg.style.display = 'none';
                        this.synthesize();
                    } catch(e) { this.notify("Invalid JSON", "error"); }
                };
                r.readAsText(f);
            },

            renderPreview() { 
                const cvs = this.els.mainCanvas; if(!this.state.texture) return;
                cvs.width = this.state.res; cvs.height = this.state.res;
                const ctx = this.ctx; ctx.clearRect(0,0,cvs.width,cvs.height);
                ctx.drawImage(this.state.texture, 0, 0);
                if(this.els.wireframeToggle.checked && this.state.model) {
                    ctx.lineWidth = Math.max(1, this.state.res/256); ctx.strokeStyle = '#00ffaa';
                    const s = this.state.res / (this.state.model["minecraft:geometry"][0].description.texture_width||64);
                    this.state.model["minecraft:geometry"][0].bones?.forEach(b => b.cubes?.forEach(c => {
                        if(Array.isArray(c.uv)) { const [u,v]=c.uv; const [w,h,d]=c.size; [[u+d,v+d,w,h],[u+d+w+d,v+d,w,h],[u,v+d,d,h],[u+d+w,v+d,d,h],[u+d,v,w,d],[u+d+w,v,w,d]].forEach(([x,y,wi,hi])=>ctx.strokeRect(x*s,y*s,wi*s,hi*s)); }
                        else Object.values(c.uv).forEach(f=>{if(f.uv&&f.uv_size)ctx.strokeRect(f.uv[0]*s,f.uv[1]*s,f.uv_size[0]*s,f.uv_size[1]*s)});
                    }));
                }
                cvs.style.transform = `translate(${this.state.view.x}px, ${this.state.view.y}px) scale(${this.state.view.scale})`;
            },
            fitView() { 
                const w=this.els.canvasWrapper; const sc=(Math.min(w.clientWidth,w.clientHeight)-40)/this.state.res; this.state.view={x:0,y:0,scale:sc,dragging:false}; this.renderPreview(); 
                if(this.state.viewMode === '3d') Viewer3D.resize(this.els['view-3d'].clientWidth, this.els['view-3d'].clientHeight);
            },
            export() { 
                if(!this.state.texture) return;
                const a=document.createElement('a'); a.download=`texture_${Date.now()}.png`; a.href=this.state.texture.src; a.click();
                const geo = JSON.parse(JSON.stringify(this.state.model)); const g = geo["minecraft:geometry"][0];
                const sX = this.state.res / (g.description.texture_width || 64), sY = this.state.res / (g.description.texture_height || 64);
                g.description.texture_width = this.state.res; g.description.texture_height = this.state.res;
                g.bones?.forEach(b => b.cubes?.forEach(c => {
                    if(Array.isArray(c.uv)) { const [u,v]=c.uv; const [w,h,d]=c.size; c.uv = { north:{uv:[(u+d)*sX,(v+d)*sY],uv_size:[w*sX,h*sY]}, south:{uv:[(u+d+w+d)*sX,(v+d)*sY],uv_size:[w*sX,h*sY]}, east:{uv:[u*sX,(v+d)*sY],uv_size:[d*sX,h*sY]}, west:{uv:[(u+d+w)*sX,(v+d)*sY],uv_size:[d*sX,h*sY]}, up:{uv:[(u+d)*sX,v*sY],uv_size:[w*sX,d*sY]}, down:{uv:[(u+d+w)*sX,v*sY],uv_size:[w*sX,d*sY]} }; }
                    else if(typeof c.uv==='object') Object.values(c.uv).forEach(f=>{if(f.uv&&f.uv_size){f.uv[0]*=sX;f.uv[1]*=sY;f.uv_size[0]*=sX;f.uv_size[1]*=sY}});
                }));
                const b=new Blob([JSON.stringify(geo,null,2)],{type:'application/json'}); const a2=document.createElement('a'); a2.href=URL.createObjectURL(b); a2.download='model.geo.json'; setTimeout(()=>a2.click(),500);
            },
            setupCanvasEvents() {
                const w=this.els.canvasWrapper;
                w.addEventListener('wheel',e=>{e.preventDefault();this.state.view.scale=Math.max(0.1,Math.min(this.state.view.scale*(1-e.deltaY*0.001),10));this.renderPreview();});
                w.addEventListener('pointerdown',e=>{this.state.view.dragging=true;this.state.view.lx=e.clientX;this.state.view.ly=e.clientY;});
                window.addEventListener('pointermove',e=>{if(this.state.view.dragging){this.state.view.x+=e.clientX-this.state.view.lx;this.state.view.y+=e.clientY-this.state.view.ly;this.state.view.lx=e.clientX;this.state.view.ly=e.clientY;this.renderPreview();}});
                window.addEventListener('pointerup',()=>this.state.view.dragging=false);
            },
            notify(m,t) { const d=document.createElement('div'); d.className=`px-3 py-2 rounded shadow-lg text-white text-xs ${t==='error'?'bg-red-900':'bg-green-900'} animate-bounce`; d.innerText=m; this.els['toast-container'].appendChild(d); setTimeout(()=>d.remove(),3000); },
            setLoading(s,t) { this.els.loaderText.innerText=t; this.els.loader.style.display=s?'flex':'none'; },
            updateResolution() { this.state.res = parseInt(this.els.resSelect.value); if(this.state.texture) this.synthesize(true); }
        };

        window.app = App;
        window.onload = () => App.init();
    </script>
</body>
</html>