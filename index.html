<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Texture DNA Lab | Dual Layer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Base Styles */
        body { background-color: #0b0f19; color: #e2e8f0; font-family: 'Segoe UI', system-ui, sans-serif; overflow: hidden; }
        
        /* Scrollbar */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: #111827; }
        ::-webkit-scrollbar-thumb { background: #374151; border-radius: 3px; }
        
        /* Utility */
        .checkerboard {
            background-color: #1a1a1a;
            background-image:
              linear-gradient(45deg, #222 25%, transparent 25%),
              linear-gradient(-45deg, #222 25%, transparent 25%),
              linear-gradient(45deg, transparent 75%, #222 75%),
              linear-gradient(-45deg, transparent 75%, #222 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }

        .loader {
            border: 3px solid rgba(255,255,255,0.1);
            border-top: 3px solid #10b981;
            border-radius: 50%;
            width: 20px; height: 20px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Step Logic */
        .step-locked { opacity: 0.5; pointer-events: none; filter: grayscale(1); }
        .step-active { opacity: 1; pointer-events: auto; filter: grayscale(0); }

        /* Layer Tabs */
        .layer-tab { transition: all 0.2s; border-bottom: 2px solid transparent; opacity: 0.6; }
        .layer-tab.active { opacity: 1; border-color: #10b981; color: #10b981; }

        /* Search Result Modal */
        .search-item:hover { background-color: #1f2937; border-color: #10b981; }
        .mini-swatch { width: 16px; height: 16px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.1); }
        
        input[type=range] { -webkit-appearance: none; background: transparent; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 12px; width: 12px; border-radius: 50%; background: #10b981; cursor: pointer; margin-top: -4px; box-shadow: 0 0 5px rgba(16,185,129,0.5);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; cursor: pointer; background: #374151; border-radius: 2px;
        }
        
        optgroup { color: #10b981; font-weight: bold; background: #111827; }
        option { color: #e2e8f0; background: #1f2937; padding: 4px; }
    </style>
</head>
<body class="h-screen flex flex-col text-sm">

    <div id="toast-container" class="fixed top-4 left-1/2 -translate-x-1/2 z-50 flex flex-col gap-2 w-max max-w-[90vw] pointer-events-none"></div>
    <input type="file" id="fileInput" accept=".json,.txt" class="hidden" onchange="app.handleFileSelect(event)">
    <input type="color" id="manualColorPicker" class="opacity-0 absolute -z-10">
    <img id="refImg" class="hidden" crossorigin="anonymous">

    <!-- SEARCH RESULTS MODAL -->
    <div id="searchModal" class="fixed inset-0 bg-black/80 z-40 hidden flex items-center justify-center p-4 backdrop-blur-sm">
        <div class="bg-gray-900 border border-gray-700 rounded-lg shadow-2xl w-full max-w-md flex flex-col max-h-[80vh]">
            <div class="p-4 border-b border-gray-800 flex justify-between items-center">
                <div><h3 class="font-bold text-green-400">Texture Library</h3><p class="text-[10px] text-gray-500" id="searchMeta">Searching...</p></div>
                <button onclick="document.getElementById('searchModal').classList.add('hidden')" class="text-gray-500 hover:text-white">‚úï</button>
            </div>
            <div id="resultsList" class="flex-1 overflow-y-auto p-2 space-y-1 custom-scrollbar"></div>
        </div>
    </div>

    <header class="h-12 bg-gray-900 border-b border-gray-800 flex items-center justify-between px-4 shrink-0 z-20">
        <div class="flex items-center gap-2">
            <div class="w-6 h-6 bg-gradient-to-br from-green-500 to-blue-600 rounded flex items-center justify-center font-bold text-white text-xs">T</div>
            <h1 class="font-bold text-gray-200 tracking-wide">Texture DNA</h1>
        </div>
        <div class="flex items-center gap-3">
            <select id="resSelect" onchange="app.updateResolution()" class="bg-gray-800 border border-gray-700 text-gray-300 text-xs rounded px-2 py-1 focus:outline-none">
                <option value="64">64px</option>
                <option value="128">128px</option>
                <option value="256">256px</option>
                <option value="512" selected>512px</option>
                <option value="1024">1024px</option>
            </select>
            <button onclick="location.reload()" class="text-xs text-gray-500 hover:text-white">Reset</button>
        </div>
    </header>

    <div class="main-layout flex-1 flex h-full overflow-hidden">
        
        <!-- SIDEBAR -->
        <div class="sidebar w-[340px] bg-gray-900 border-r border-gray-800 flex flex-col shrink-0 overflow-y-auto custom-scrollbar">
            
            <!-- 1. Geometry -->
            <div class="p-4 border-b border-gray-800">
                <div class="flex justify-between items-center mb-2">
                    <label class="font-bold text-blue-400 text-xs uppercase">1. Geometry</label>
                    <span id="modelStatus" class="text-[10px] text-gray-500 bg-gray-800 px-1.5 py-0.5 rounded border border-gray-700">None</span>
                </div>
                <div onclick="document.getElementById('fileInput').click()" 
                     class="border border-dashed border-gray-600 bg-gray-800/40 hover:bg-gray-800 hover:border-blue-400 transition-all rounded p-4 cursor-pointer text-center group">
                    <p id="fileName" class="text-xs text-gray-400 group-hover:text-blue-300 font-medium">Click to Upload .geo.json</p>
                </div>
            </div>

            <!-- 2. Synthesis -->
            <div id="step2" class="p-4 border-b border-gray-800 step-locked flex-1">
                <div class="flex justify-between items-center mb-2">
                    <label class="font-bold text-green-400 text-xs uppercase">2. Synthesizer</label>
                    <button onclick="app.randomizeParams()" class="text-xs text-gray-500 hover:text-green-400" title="Randomize Current Layer">üé≤ Remix Layer</button>
                </div>

                <!-- Layer Switcher -->
                <div class="flex border-b border-gray-700 mb-4">
                    <button onclick="app.setLayer(0)" id="tab-0" class="layer-tab active flex-1 py-2 text-xs font-bold text-center hover:bg-gray-800">Background</button>
                    <button onclick="app.setLayer(1)" id="tab-1" class="layer-tab flex-1 py-2 text-xs font-bold text-center hover:bg-gray-800">Foreground</button>
                </div>

                <!-- Engine Controls -->
                <div class="bg-black/20 rounded border border-gray-700 p-3 mb-4 space-y-3 relative">
                    
                    <!-- Preset Selector -->
                    <div>
                        <div class="flex justify-between mb-1">
                            <span class="text-[10px] text-gray-400 uppercase">Layer Preset</span>
                        </div>
                        <select id="presetSelector" onchange="app.applyPreset(this.value)" class="w-full bg-gray-800 border border-gray-600 text-xs text-white rounded px-2 py-1.5 cursor-pointer focus:border-green-500 focus:outline-none">
                            <option value="" disabled selected>Choose Material...</option>
                        </select>
                    </div>

                    <!-- Palette & DNA -->
                    <div>
                        <div class="flex justify-between text-[10px] text-gray-400 mb-1">
                            <span>Palette</span>
                            <button onclick="app.searchReference()" class="text-[10px] text-blue-400 hover:text-blue-300">üîç Search Ref</button>
                        </div>
                        <div class="grid grid-cols-6 gap-0.5 h-6 rounded overflow-hidden border border-gray-700" id="paletteBox"></div>
                    </div>

                    <!-- Search Source -->
                    <div class="mb-2">
                        <div class="flex gap-1">
                            <input id="searchQuery" type="text" placeholder="Ref Search (e.g. 'oak', 'stone')" 
                                   class="flex-1 bg-gray-800 border border-gray-700 rounded px-2 py-1.5 text-xs text-white focus:border-green-500 focus:outline-none"
                                   onkeypress="if(event.key==='Enter') app.searchReference()">
                            <button onclick="app.searchReference()" class="bg-gray-700 hover:bg-gray-600 text-white px-2.5 rounded text-xs">üîç</button>
                        </div>
                    </div>

                    <!-- Sliders -->
                    <div class="space-y-3 pt-2 border-t border-gray-700/50">
                        
                        <div class="grid grid-cols-2 gap-x-4 gap-y-2">
                            <div>
                                <div class="flex justify-between mb-1"><span class="text-[10px] text-gray-400">Scale</span><span id="val-scale" class="text-[9px] text-green-400">50</span></div>
                                <input type="range" id="scaleLevel" min="1" max="100" value="50" class="w-full h-1" oninput="app.updateUIVal('scale', this.value)">
                            </div>
                            <div>
                                <div class="flex justify-between mb-1"><span class="text-[10px] text-gray-400">Chaos</span><span id="val-chaos" class="text-[9px] text-green-400">20</span></div>
                                <input type="range" id="chaosLevel" min="0" max="100" value="20" class="w-full h-1" oninput="app.updateUIVal('chaos', this.value)">
                            </div>
                            <div>
                                <div class="flex justify-between mb-1"><span class="text-[10px] text-gray-400">Roughness</span><span id="val-noise" class="text-[9px] text-green-400">30</span></div>
                                <input type="range" id="noiseLevel" min="0" max="100" value="30" class="w-full h-1" oninput="app.updateUIVal('noise', this.value)">
                            </div>
                            <div>
                                <div class="flex justify-between mb-1"><span class="text-[10px] text-gray-400">Contrast</span><span id="val-contrast" class="text-[9px] text-green-400">50</span></div>
                                <input type="range" id="contrastLevel" min="0" max="100" value="50" class="w-full h-1" oninput="app.updateUIVal('contrast', this.value)">
                            </div>
                        </div>

                        <div>
                            <div class="flex justify-between mb-1"><span class="text-[10px] text-gray-400">Saturation</span><span id="val-sat" class="text-[9px] text-blue-400">100%</span></div>
                            <input type="range" id="satLevel" min="0" max="200" value="100" class="w-full h-1 accent-blue-500" oninput="app.updateUIVal('sat', this.value)">
                        </div>

                        <!-- FOREGROUND ONLY: Opacity -->
                        <div id="opacityControl" class="hidden border-t border-gray-700 pt-2">
                            <div class="flex justify-between mb-1"><span class="text-[10px] text-yellow-400 font-bold">Layer Opacity</span><span id="val-opacity" class="text-[9px] text-yellow-400">50%</span></div>
                            <input type="range" id="opacityLevel" min="0" max="100" value="50" class="w-full h-1 accent-yellow-500" oninput="app.updateUIVal('opacity', this.value)">
                        </div>

                    </div>
                </div>

                <button onclick="app.synthesize()" class="w-full py-2.5 bg-gradient-to-r from-green-600 to-emerald-600 hover:from-green-500 hover:to-emerald-500 text-white font-bold text-xs rounded shadow-lg shadow-green-900/20 transition-all flex items-center justify-center gap-2">
                    <span>Generate Composite</span>
                </button>
                
                <div class="mt-2 text-center">
                    <label class="text-[10px] text-gray-400 flex items-center justify-center gap-1 cursor-pointer">
                        <input type="checkbox" id="wireframeToggle" checked onchange="app.renderPreview()" class="accent-green-500"> Show UV Overlay
                    </label>
                </div>
            </div>

            <!-- 3. Export -->
            <div id="step3" class="p-4 step-locked">
                 <button onclick="app.export()" class="w-full py-2 bg-blue-600 hover:bg-blue-500 text-white font-bold text-xs rounded">
                    Download Assets
                </button>
            </div>
        </div>

        <!-- CANVAS AREA -->
        <div class="canvas-area flex-1 bg-[#050505] relative flex flex-col min-w-0 overflow-hidden">
            <div id="canvasWrapper" class="absolute inset-0 checkerboard flex items-center justify-center cursor-grab touch-none">
                <canvas id="mainCanvas" class="shadow-2xl"></canvas>
            </div>
            <div id="viewportMsg" class="absolute inset-0 flex flex-col items-center justify-center text-gray-600 pointer-events-none z-10 bg-black/50 backdrop-blur-sm transition-opacity duration-300">
                <p class="text-sm font-medium text-gray-300">Workspace Empty</p>
                <p class="text-xs mt-1 opacity-60">Upload .geo.json to begin</p>
            </div>
            <div id="loader" class="absolute inset-0 bg-black/80 z-50 hidden flex-col items-center justify-center backdrop-blur-sm">
                <div class="loader mb-2"></div>
                <p id="loaderText" class="text-green-400 text-[10px] font-mono uppercase animate-pulse">Processing...</p>
            </div>
            <div class="absolute bottom-4 right-4 flex gap-2 z-20">
                <button onclick="app.fitView()" class="bg-gray-800/80 hover:bg-gray-700 text-white p-2 rounded backdrop-blur border border-gray-600 shadow-lg" title="Reset View">
                    <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"></path></svg>
                </button>
            </div>
        </div>
    </div>

    <script>
        const PRESETS = {
            "Woods": { "Oak Planks":{type:"wood",scale:0.5,chaos:0.1,noise:0.2,contrast:0.5,sat:1.0}, "Spruce":{type:"wood",scale:0.6,chaos:0.05,noise:0.15,contrast:0.4,sat:0.9}, "Birch":{type:"wood",scale:0.5,chaos:0.05,noise:0.1,contrast:0.3,sat:0.95}, "Jungle":{type:"wood",scale:0.4,chaos:0.2,noise:0.4,contrast:0.6,sat:1.1}, "Dark Oak":{type:"wood",scale:0.6,chaos:0.05,noise:0.15,contrast:0.6,sat:0.9}, "Rotting":{type:"wood",scale:0.5,chaos:0.6,noise:0.8,contrast:0.7,sat:0.7} },
            "Stones": { "Cobble":{type:"stone",scale:0.4,chaos:0.6,noise:0.5,contrast:0.7,sat:0.8}, "Smooth":{type:"stone",scale:0.2,chaos:0.1,noise:0.2,contrast:0.3,sat:0.9}, "Granite":{type:"stone",scale:0.7,chaos:0.8,noise:0.6,contrast:0.6,sat:1.1}, "Bedrock":{type:"stone",scale:0.8,chaos:0.9,noise:0.9,contrast:1.0,sat:0.8} },
            "Construction": { "Bricks":{type:"bricks",scale:0.5,chaos:0.1,noise:0.3,contrast:0.6,sat:1.1}, "Stone Brick":{type:"bricks",scale:0.4,chaos:0.05,noise:0.2,contrast:0.5,sat:0.9}, "Tiles":{type:"bricks",scale:0.8,chaos:0.0,noise:0.1,contrast:0.5,sat:1.0}, "Ruined":{type:"bricks",scale:0.5,chaos:0.7,noise:0.9,contrast:0.7,sat:0.7} },
            "Metals": { "Iron":{type:"metal",scale:0.3,chaos:0.1,noise:0.2,contrast:0.4,sat:0.8}, "Gold":{type:"metal",scale:0.3,chaos:0.1,noise:0.15,contrast:0.6,sat:1.2}, "Rust":{type:"metal",scale:0.6,chaos:0.7,noise:0.8,contrast:0.8,sat:1.1}, "Chrome":{type:"metal",scale:0.1,chaos:0.0,noise:0.05,contrast:0.9,sat:0.0} },
            "Organics": { "Scales":{type:"scales",scale:0.4,chaos:0.1,noise:0.3,contrast:0.7,sat:1.0}, "Alien":{type:"scales",scale:0.5,chaos:0.6,noise:0.5,contrast:0.4,sat:1.3}, "Dirt":{type:"stone",scale:1.0,chaos:0.8,noise:0.8,contrast:0.3,sat:0.9} },
            "Fabrics": { "Wool":{type:"weave",scale:0.8,chaos:0.1,noise:0.4,contrast:0.3,sat:1.0}, "Kevlar":{type:"weave",scale:0.65,chaos:0.05,noise:0.2,contrast:0.6,sat:1.0}, "Carbon":{type:"weave",scale:0.6,chaos:0.0,noise:0.1,contrast:0.8,sat:0.5} }
        };

        const TextureEngine = {
            adjustSat(r, g, b, sat) {
                const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                const s = sat;
                return [Math.min(255,Math.max(0,gray+(r-gray)*s)), Math.min(255,Math.max(0,gray+(g-gray)*s)), Math.min(255,Math.max(0,gray+(b-gray)*s))];
            },
            parseColor(hexOrRgb) {
                if(hexOrRgb.startsWith('#')) return [(parseInt(hexOrRgb.slice(1),16)>>16)&255, (parseInt(hexOrRgb.slice(1),16)>>8)&255, parseInt(hexOrRgb.slice(1),16)&255];
                return hexOrRgb.match(/\d+/g).map(Number);
            },
            analyze(imgElement) {
                const cvs = document.createElement('canvas'); cvs.width=64; cvs.height=64;
                const ctx = cvs.getContext('2d'); ctx.drawImage(imgElement,0,0,64,64);
                const data = ctx.getImageData(0,0,64,64).data;
                const colors = {}; let edges = 0;
                for(let i=0;i<data.length;i+=4) {
                    if(data[i+3]<128) continue;
                    const k=`${Math.round(data[i]/10)*10},${Math.round(data[i+1]/10)*10},${Math.round(data[i+2]/10)*10}`;
                    colors[k]=(colors[k]||0)+1;
                    if(i<data.length-4) { const l1=(data[i]+data[i+1]+data[i+2])/3, l2=(data[i+4]+data[i+5]+data[i+6])/3; if(Math.abs(l1-l2)>20) edges++; }
                }
                const sorted = Object.keys(colors).sort((a,b)=>colors[b]-colors[a]).slice(0,10).sort((a,b)=>{ const [r1,g1,b1]=a.split(',').map(Number), [r2,g2,b2]=b.split(',').map(Number); return (r1+g1+b1)-(r2+g2+b2);});
                const palette = []; for(let i=0;i<6;i++) { const c=sorted[Math.floor(i*(sorted.length/6))]||sorted[0]; if(c) palette.push(`rgb(${c})`); }
                return { palette, edgeRatio: edges/(64*64) };
            },
            render(ctx, x, y, w, h, config, isOverlay) {
                ctx.save(); ctx.beginPath(); ctx.rect(x, y, w, h); ctx.clip(); ctx.translate(x, y);
                const { type, palette, scale, chaos, noise, contrast, sat, opacity } = config;
                const p = palette.map(c => { const [r,g,b]=this.parseColor(c); const [nr,ng,nb]=this.adjustSat(r,g,b,sat); return `rgb(${Math.floor(nr)},${Math.floor(ng)},${Math.floor(nb)})`; });
                
                if (isOverlay) ctx.globalAlpha = opacity / 100;

                // Base Fill
                if (!isOverlay || (isOverlay && chaos < 0.5)) { 
                    ctx.fillStyle = p[2]; ctx.fillRect(0, 0, w, h);
                }

                // Generator Routing
                if (type === 'wood') this.genWood(ctx, w, h, p, scale, chaos, contrast);
                else if (type === 'bricks') this.genBricks(ctx, w, h, p, scale, chaos, contrast);
                else if (type === 'scales') this.genCells(ctx, w, h, p, scale, chaos, contrast);
                else if (type === 'metal') this.genMetal(ctx, w, h, p, scale, chaos, contrast);
                else if (type === 'weave') this.genWeave(ctx, w, h, p, scale, chaos, contrast);
                else this.genNoise(ctx, w, h, p, scale, chaos, contrast); 

                // Finish
                if (noise > 0.05) this.genGrain(ctx, w, h, noise);
                if (chaos > 0.2) this.genGrunge(ctx, w, h, noise * 0.5 + chaos * 0.2);

                ctx.restore();
            },

            // --- PRECISE GENERATORS ---

            genWood(ctx, w, h, p, scale, chaos, contrast) {
                // Calculate orientation based on dimensions
                const isHorz = w >= h;
                
                // Scale determines plank count: 0.0-1.0 -> 2-8 planks
                // Important: Integer plank count for clean lines
                const plankCount = Math.max(2, Math.floor(2 + scale * 6)); 
                const plankSize = (isHorz ? h : w) / plankCount;

                for (let i = 0; i < plankCount; i++) {
                    const pos = i * plankSize;
                    
                    // Plank Base
                    ctx.fillStyle = (i % 2 === 0) ? p[2] : p[3];
                    if (isHorz) ctx.fillRect(0, pos, w, plankSize);
                    else ctx.fillRect(pos, 0, plankSize, h);

                    // Grain (Inside planks)
                    ctx.fillStyle = p[1];
                    ctx.globalAlpha = 0.1 + (contrast * 0.2);
                    const grainDensity = Math.floor(plankSize * 0.5); // Lines per plank
                    
                    for (let g = 0; g < grainDensity; g++) {
                        const gPos = pos + (Math.random() * plankSize);
                        const len = (isHorz ? w : h) * (0.2 + Math.random() * 0.8); // Length of grain line
                        const start = Math.random() * ((isHorz ? w : h) - len);
                        
                        // Chaos adds slight wiggle to grain
                        const wiggle = (Math.random() - 0.5) * (chaos * 4);

                        if (isHorz) ctx.fillRect(start, gPos + wiggle, len, 1);
                        else ctx.fillRect(gPos + wiggle, start, 1, len);
                    }
                    ctx.globalAlpha = 1.0;

                    // Separator Line (Dark, crisp)
                    if (i > 0) {
                        ctx.fillStyle = p[0];
                        ctx.globalAlpha = 0.6 + (contrast * 0.4);
                        if (isHorz) ctx.fillRect(0, pos, w, 1); // Horizontal line
                        else ctx.fillRect(pos, 0, 1, h); // Vertical line
                        ctx.globalAlpha = 1.0;
                    }
                }
            },

            genBricks(ctx, w, h, p, scale, chaos, contrast) {
                ctx.fillStyle = p[0]; ctx.fillRect(0,0,w,h); // Mortar base
                
                const rows = Math.max(2, Math.floor(2 + scale * 8));
                const cols = Math.max(2, Math.floor(2 + scale * 4));
                const bH = h / rows;
                const bW = w / cols;
                const gap = Math.max(1, Math.floor(Math.min(w,h) * 0.02)); // 2% gap minimum 1px

                for (let r = 0; r < rows; r++) {
                    const offset = (r % 2) * (bW / 2);
                    // Draw extra column to cover offset wrap
                    for (let c = -1; c <= cols; c++) {
                        // Chaos: Randomly skip brick (ruined look)
                        if (chaos > 0.5 && Math.random() < (chaos - 0.5) * 0.2) continue;

                        // Color variety
                        const rnd = Math.random();
                        if (rnd > 0.9 - (contrast * 0.2)) ctx.fillStyle = p[4];
                        else if (rnd > 0.4) ctx.fillStyle = p[3];
                        else ctx.fillStyle = p[2];

                        // Chaos: Offset jitter (Horizontal only for structural integrity)
                        const jx = (Math.random() - 0.5) * (chaos * gap * 2);
                        
                        ctx.fillRect(
                            (c * bW) + offset + gap + jx, 
                            (r * bH) + gap, 
                            Math.max(1, bW - gap*2), 
                            Math.max(1, bH - gap*2)
                        );
                    }
                }
            },

            genWeave(ctx, w, h, p, scale, chaos, contrast) {
                // Thread size depends on scale (smaller scale = bigger threads)
                const thread = Math.max(2, Math.floor(12 - (scale * 10)));
                const cols = Math.ceil(w / thread);
                const rows = Math.ceil(h / thread);

                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        const isVert = (r + c) % 2 === 0;
                        
                        // Base thread color
                        ctx.fillStyle = isVert ? p[2] : p[3];
                        // Occasional highlight thread
                        if (Math.random() > 0.95) ctx.fillStyle = p[4];

                        ctx.fillRect(c*thread, r*thread, thread, thread);

                        // Shading for depth (The "Weave" look)
                        ctx.fillStyle = '#000';
                        ctx.globalAlpha = 0.3 * contrast;
                        if (isVert) {
                            ctx.fillRect(c*thread, r*thread, 1, thread); // Left shadow
                            ctx.fillRect((c+1)*thread - 1, r*thread, 1, thread); // Right shadow
                        } else {
                            ctx.fillRect(c*thread, r*thread, thread, 1); // Top shadow
                            ctx.fillRect(c*thread, (r+1)*thread - 1, thread, 1); // Bottom shadow
                        }
                        ctx.globalAlpha = 1.0;
                    }
                }
            },

            genCells(ctx, w, h, p, scale, chaos, contrast) {
                const cellS = Math.max(4, Math.floor(32 - (scale * 24))); // 4px to 32px
                
                for (let y = 0; y < h; y += cellS) {
                    for (let x = 0; x < w; x += cellS) {
                        ctx.fillStyle = (Math.random() > 0.5) ? p[3] : p[2];
                        
                        // Chaos: Jitter position
                        const jx = (Math.random()-0.5) * (chaos * cellS);
                        const jy = (Math.random()-0.5) * (chaos * cellS);
                        
                        // Draw Square Cell (Not circle)
                        const size = Math.max(2, cellS - 1);
                        ctx.fillRect(x + jx, y + jy, size, size);

                        // Highlight center
                        if (contrast > 0.5) {
                            ctx.fillStyle = p[4];
                            ctx.globalAlpha = 0.3;
                            ctx.fillRect(x + jx + size/4, y + jy + size/4, size/2, size/2);
                            ctx.globalAlpha = 1.0;
                        }
                    }
                }
            },

            genMetal(ctx, w, h, p, scale, chaos, contrast) {
                const grad = ctx.createLinearGradient(0,0,w,h); 
                grad.addColorStop(0,p[2]); grad.addColorStop(1,p[4]); 
                ctx.fillStyle=grad; ctx.fillRect(0,0,w,h);
                
                // Scratches
                ctx.strokeStyle=p[5]; 
                ctx.globalAlpha=0.2 * contrast;
                const count = 5 + (chaos * 20);
                
                ctx.beginPath();
                for(let i=0; i<count; i++) {
                    const sx=Math.random()*w, sy=Math.random()*h;
                    const len=(w*0.2) * (1 + Math.random()); // Length based on scale/size
                    ctx.moveTo(sx,sy); ctx.lineTo(sx+len, sy+len);
                }
                ctx.stroke();
                ctx.globalAlpha=1.0;
            },

            genNoise(ctx, w, h, p, scale, chaos, contrast) {
                // Blocky Noise
                const count = (w*h) * 0.1 * scale;
                for(let i=0; i<count; i++) {
                    ctx.fillStyle = (Math.random()>0.5) ? p[1] : p[3];
                    ctx.globalAlpha = 0.3 * contrast;
                    const s = 1 + Math.random() * (scale * 4);
                    ctx.fillRect(Math.random()*w, Math.random()*h, s, s);
                }
                ctx.globalAlpha=1.0;
            },

            genGrain(ctx, w, h, amt) {
                ctx.fillStyle = '#000';
                ctx.globalAlpha = amt * 0.15;
                const count = w*h*0.5;
                for(let i=0; i<count; i++) ctx.fillRect(Math.random()*w, Math.random()*h, 1, 1);
                ctx.globalAlpha = 1.0;
            },

            genGrunge(ctx, w, h, amt) {
                if(amt < 0.05) return;
                ctx.fillStyle = '#1a0f00';
                ctx.globalAlpha = Math.min(0.8, amt);
                const blobs = 2 + (amt * 10);
                for(let i=0; i<blobs; i++) {
                    const s = Math.random() * (Math.min(w,h)/2);
                    if(s > 2) ctx.fillRect(Math.random()*w, Math.random()*h, s, s); // Square grunge
                }
                ctx.globalAlpha = 1.0;
            }
        };

        const App = {
            state: {
                model: null,
                texture: null,
                res: 512,
                layers: [
                    { type:'wood', palette:['#3e2723','#4e342e','#5d4037','#6d4c41','#795548','#8d6e63'], scale:0.5, chaos:0.1, noise:0.2, contrast:0.5, sat:1 },
                    { type:'stone', palette:['#000000','#1a1a1a','#333333','#4d4d4d','#666666','#808080'], scale:0.8, chaos:0.5, noise:0.5, contrast:0.5, sat:1, opacity:50 }
                ],
                activeLayer: 0,
                view: { x: 0, y: 0, scale: 1, dragging: false, lx: 0, ly: 0 }
            },
            els: {},

            init() {
                const ids = ['fileInput','fileName','step2','step3','canvasWrapper','mainCanvas','viewportMsg',
                             'loader','loaderText','resSelect','presetSelector','paletteBox','manualColorPicker',
                             'searchQuery','refImg','noiseLevel','contrastLevel','scaleLevel','chaosLevel','satLevel','opacityLevel','opacityControl',
                             'wireframeToggle','toast-container','searchModal','resultsList'];
                ids.forEach(id => this.els[id] = document.getElementById(id));

                this.ctx = this.els.mainCanvas.getContext('2d');
                this.initPresets();
                this.setLayer(0);
                this.setupCanvasEvents();
                
                this.els.manualColorPicker.addEventListener('input', (e) => {
                    if(this.state.activeColorIdx > -1) {
                        this.state.layers[this.state.activeLayer].palette[this.state.activeColorIdx] = e.target.value;
                        this.renderPalette();
                        if(this.state.texture) this.synthesize(true);
                    }
                });
                window.addEventListener('resize', () => { if(this.state.texture) this.fitView(); });
            },

            initPresets() {
                const sel = this.els.presetSelector;
                sel.innerHTML = '<option value="" disabled selected>Choose Material...</option>';
                for (const [category, items] of Object.entries(PRESETS)) {
                    const group = document.createElement('optgroup'); group.label = category;
                    for (const name of Object.keys(items)) {
                        const opt = document.createElement('option'); opt.value = `${category}:${name}`; opt.innerText = name; group.appendChild(opt);
                    }
                    sel.appendChild(group);
                }
            },

            setLayer(idx) {
                this.state.activeLayer = idx;
                document.getElementById('tab-0').className = `layer-tab flex-1 py-2 text-xs font-bold text-center hover:bg-gray-800 ${idx===0?'active':''}`;
                document.getElementById('tab-1').className = `layer-tab flex-1 py-2 text-xs font-bold text-center hover:bg-gray-800 ${idx===1?'active':''}`;
                
                const l = this.state.layers[idx];
                this.els.scaleLevel.value = l.scale * 100;
                this.els.chaosLevel.value = l.chaos * 100;
                this.els.noiseLevel.value = l.noise * 100;
                this.els.contrastLevel.value = l.contrast * 100;
                this.els.satLevel.value = l.sat * 100;
                if(idx===1) {
                    this.els.opacityLevel.value = l.opacity;
                    this.els.opacityControl.classList.remove('hidden');
                } else {
                    this.els.opacityControl.classList.add('hidden');
                }
                
                ['scale','chaos','noise','contrast','sat'].forEach(k => this.updateUINum(k, l[k]*100));
                if(idx===1) this.updateUINum('opacity', l.opacity);
                this.renderPalette();
            },

            updateUINum(k, v) {
                const el = document.getElementById(k==='noise'?'val-noise':k==='sat'?'val-sat':k==='opacity'?'val-opacity':`val-${k}`);
                if(el) el.innerText = (k==='sat'||k==='opacity') ? v+'%' : v;
            },

            updateUIVal(key, val) {
                const l = this.state.layers[this.state.activeLayer];
                if(key === 'opacity') l.opacity = parseInt(val);
                else l[key] = parseInt(val) / 100;
                this.updateUINum(key, val);
                if(this.state.texture) this.synthesize(true);
            },

            applyPreset(val) {
                const [cat, name] = val.split(':');
                const p = PRESETS[cat][name];
                const l = this.state.layers[this.state.activeLayer];
                l.type = p.type; l.scale = p.scale; l.chaos = p.chaos; l.noise = p.noise; l.contrast = p.contrast; l.sat = p.sat;
                this.setLayer(this.state.activeLayer); // Refresh UI
                if(this.state.texture) this.synthesize(true);
                this.notify(`Applied: ${name}`, "success");
            },

            randomizeParams() {
                const l = this.state.layers[this.state.activeLayer];
                l.scale = (Math.floor(Math.random() * 90) + 10)/100;
                l.chaos = (Math.floor(Math.random() * 60))/100;
                l.noise = (Math.floor(Math.random() * 50) + 10)/100;
                l.contrast = (Math.floor(Math.random() * 60) + 20)/100;
                l.sat = (Math.floor(Math.random() * 100) + 50)/100;
                this.setLayer(this.state.activeLayer);
                if(this.state.texture) this.synthesize(true);
                this.notify("Layer Remixed!", "success");
            },

            synthesize(silent = false) {
                if(!this.state.model) return this.notify("No model loaded", "error");
                if(!silent) this.setLoading(true, "Synthesizing...");

                requestAnimationFrame(() => {
                    try {
                        const size = this.state.res;
                        const cvs = document.createElement('canvas'); cvs.width = size; cvs.height = size;
                        const ctx = cvs.getContext('2d'); ctx.clearRect(0, 0, size, size);

                        const geo = this.state.model["minecraft:geometry"][0];
                        const scaleX = size / (geo.description.texture_width || 64);
                        const scaleY = size / (geo.description.texture_height || 64);

                        geo.bones?.forEach(bone => {
                            if(!bone.cubes) return;
                            bone.cubes.forEach(cube => {
                                if (Array.isArray(cube.uv)) {
                                    const [u, v] = cube.uv; const [w, h, d] = cube.size;
                                    const faces = [{ x: u+d, y: v+d, w: w, h: h }, { x: u+d+w+d, y: v+d, w: w, h: h }, { x: u, y: v+d, w: d, h: h }, { x: u+d+w, y: v+d, w: d, h: h }, { x: u+d, y: v, w: w, h: d }, { x: u+d+w, y: v, w: w, h: d }];
                                    faces.forEach(f => {
                                        const rx=Math.floor(f.x*scaleX), ry=Math.floor(f.y*scaleY), rw=Math.ceil(f.w*scaleX), rh=Math.ceil(f.h*scaleY);
                                        TextureEngine.render(ctx, rx, ry, rw, rh, this.state.layers[0], false); // Base
                                        if(this.state.layers[1].opacity > 0) TextureEngine.render(ctx, rx, ry, rw, rh, this.state.layers[1], true); // Overlay
                                    });
                                } else if (typeof cube.uv === 'object') {
                                    Object.values(cube.uv).forEach(d => {
                                        if(d.uv && d.uv_size) {
                                            const rx=Math.floor(d.uv[0]*scaleX), ry=Math.floor(d.uv[1]*scaleY), rw=Math.ceil(d.uv_size[0]*scaleX), rh=Math.ceil(d.uv_size[1]*scaleY);
                                            TextureEngine.render(ctx, rx, ry, rw, rh, this.state.layers[0], false);
                                            if(this.state.layers[1].opacity > 0) TextureEngine.render(ctx, rx, ry, rw, rh, this.state.layers[1], true);
                                        }
                                    });
                                }
                            });
                        });

                        const img = new Image();
                        img.onload = () => {
                            this.state.texture = img;
                            this.renderPreview();
                            if(!silent) {
                                this.fitView();
                                this.setLoading(false);
                                this.els.step3.classList.remove('step-locked');
                                this.els.step3.classList.add('step-active');
                                this.notify("Texture Composite Generated", "success");
                            }
                        };
                        img.src = cvs.toDataURL();
                    } catch(e) { this.setLoading(false); this.notify(e.message, "error"); }
                });
            },

            // --- DNA & Search ---
            async searchReference() {
                const input = document.getElementById('searchQuery');
                if(!input) return this.notify("Search unavailable", "error");
                const q = input.value.trim();
                if(!q) return this.notify("Enter query", "error");
                this.setLoading(true, "Scanning...");
                try {
                    const res = await fetch(`https://api.github.com/repos/kingofcoding9/Wireframe-Texture-Creator/git/trees/main?recursive=1`);
                    if(!res.ok) throw new Error("Repo Error");
                    const data = await res.json();
                    const matches = data.tree.filter(n => n.type==='blob' && n.path.match(/\.(png|jpg)$/i) && n.path.toLowerCase().includes(q.toLowerCase()));
                    if(!matches.length) throw new Error("No matches");
                    this.showResults(matches.map(n => ({ name: n.path.split('/').pop(), path: n.path, download_url: `https://raw.githubusercontent.com/kingofcoding9/Wireframe-Texture-Creator/main/${n.path}`, sha: n.sha })));
                    this.setLoading(false);
                } catch(e) { this.setLoading(false); this.notify(e.message, "error"); }
            },

            showResults(matches) {
                const list = this.els.resultsList; list.innerHTML = '';
                matches.slice(0, 50).forEach(file => {
                    const div = document.createElement('div');
                    div.className = "search-item p-3 bg-gray-800 border border-gray-700 rounded cursor-pointer transition-colors flex items-center gap-3 relative";
                    div.innerHTML = `
                        <div class="w-10 h-10 bg-gray-700 rounded flex items-center justify-center text-xs text-gray-500 overflow-hidden shrink-0"><div class="animate-pulse w-full h-full bg-gray-600"></div></div>
                        <div class="flex-1 min-w-0"><div class="text-xs text-gray-200 font-bold truncate">${file.name}</div><div class="flex gap-0.5 mt-1 h-2 w-full" id="palette-${file.sha}"></div></div>
                    `;
                    div.onclick = () => { this.els.searchModal.classList.add('hidden'); this.processImage(file.download_url, file.name); };
                    list.appendChild(div);
                    const img = new Image(); img.crossOrigin = "Anonymous"; img.src = file.download_url;
                    img.onload = () => {
                        const dna = TextureEngine.analyze(img);
                        const pal = document.getElementById(`palette-${file.sha}`);
                        if(pal) dna.palette.forEach(c => { const s=document.createElement('div'); s.className='flex-1 h-full rounded-sm'; s.style.backgroundColor=c; pal.appendChild(s); });
                        div.querySelector('.w-10').innerHTML = `<img src="${file.download_url}" class="w-full h-full object-cover">`;
                    };
                });
                document.getElementById('searchMeta').textContent = `Found ${matches.length} items`;
                this.els.searchModal.classList.remove('hidden');
            },

            processImage(url, name) {
                this.setLoading(true, "Analyzing DNA...");
                const img = this.els.refImg; img.crossOrigin = "Anonymous";
                img.onload = () => {
                    const dna = TextureEngine.analyze(img);
                    const l = this.state.layers[this.state.activeLayer];
                    l.palette = dna.palette;
                    this.renderPalette();
                    this.notify(`Palette loaded to Layer ${this.state.activeLayer+1}`, "success");
                    this.setLoading(false);
                    if(this.state.model) this.synthesize(true);
                };
                img.src = url;
            },

            renderPalette() {
                const box = this.els.paletteBox; box.innerHTML = '';
                const pal = this.state.layers[this.state.activeLayer].palette;
                pal.forEach((c,i) => {
                    const d = document.createElement('div'); d.className = 'w-full h-full cursor-pointer hover:opacity-80'; d.style.backgroundColor = c;
                    d.onclick = () => { this.state.activeColorIdx = i; this.els.manualColorPicker.click(); };
                    box.appendChild(d);
                });
            },

            handleFileSelect(e) {
                const f = e.target.files[0]; if(!f) return;
                const r = new FileReader();
                r.onload = (ev) => {
                    try {
                        this.state.model = JSON.parse(ev.target.result);
                        document.getElementById('fileName').textContent = f.name;
                        document.getElementById('modelStatus').textContent = "Loaded";
                        document.getElementById('modelStatus').className = "text-[10px] text-green-400 bg-green-900 px-1.5 py-0.5 rounded border border-green-700";
                        this.els.step2.classList.remove('step-locked');
                        this.els.step2.classList.add('step-active');
                        this.els.viewportMsg.style.display = 'none'; // FIX: Hides overlay
                        this.synthesize();
                    } catch(e) { this.notify("Invalid JSON", "error"); }
                };
                r.readAsText(f);
            },

            // ... [Keep renderPreview, fitView, export, setupCanvasEvents exactly as before] ...
            
            renderPreview() { 
                const cvs = this.els.mainCanvas; if(!this.state.texture) return;
                cvs.width = this.state.res; cvs.height = this.state.res;
                const ctx = this.ctx; ctx.clearRect(0,0,cvs.width,cvs.height);
                ctx.drawImage(this.state.texture, 0, 0);
                if(this.els.wireframeToggle.checked && this.state.model) {
                    ctx.lineWidth = Math.max(1, this.state.res/256); ctx.strokeStyle = '#00ffaa';
                    const s = this.state.res / (this.state.model["minecraft:geometry"][0].description.texture_width||64);
                    this.state.model["minecraft:geometry"][0].bones?.forEach(b => b.cubes?.forEach(c => {
                        if(Array.isArray(c.uv)) { const [u,v]=c.uv; const [w,h,d]=c.size; [[u+d,v+d,w,h],[u+d+w+d,v+d,w,h],[u,v+d,d,h],[u+d+w,v+d,d,h],[u+d,v,w,d],[u+d+w,v,w,d]].forEach(([x,y,wi,hi])=>ctx.strokeRect(x*s,y*s,wi*s,hi*s)); }
                        else Object.values(c.uv).forEach(f=>{if(f.uv&&f.uv_size)ctx.strokeRect(f.uv[0]*s,f.uv[1]*s,f.uv_size[0]*s,f.uv_size[1]*s)});
                    }));
                }
                cvs.style.transform = `translate(${this.state.view.x}px, ${this.state.view.y}px) scale(${this.state.view.scale})`;
            },
            fitView() { const w=this.els.canvasWrapper; const sc=(Math.min(w.clientWidth,w.clientHeight)-40)/this.state.res; this.state.view={x:0,y:0,scale:sc,dragging:false}; this.renderPreview(); },
            export() { 
                if(!this.state.texture) return;
                const a=document.createElement('a'); a.download=`texture_${Date.now()}.png`; a.href=this.state.texture.src; a.click();
                const geo = JSON.parse(JSON.stringify(this.state.model)); const g = geo["minecraft:geometry"][0];
                const sX = this.state.res / (g.description.texture_width || 64), sY = this.state.res / (g.description.texture_height || 64);
                g.description.texture_width = this.state.res; g.description.texture_height = this.state.res;
                g.bones?.forEach(b => b.cubes?.forEach(c => {
                    if(Array.isArray(c.uv)) { const [u,v]=c.uv; const [w,h,d]=c.size; c.uv = { north:{uv:[(u+d)*sX,(v+d)*sY],uv_size:[w*sX,h*sY]}, south:{uv:[(u+d+w+d)*sX,(v+d)*sY],uv_size:[w*sX,h*sY]}, east:{uv:[u*sX,(v+d)*sY],uv_size:[d*sX,h*sY]}, west:{uv:[(u+d+w)*sX,(v+d)*sY],uv_size:[d*sX,h*sY]}, up:{uv:[(u+d)*sX,v*sY],uv_size:[w*sX,d*sY]}, down:{uv:[(u+d+w)*sX,v*sY],uv_size:[w*sX,d*sY]} }; }
                    else if(typeof c.uv==='object') Object.values(c.uv).forEach(f=>{if(f.uv&&f.uv_size){f.uv[0]*=sX;f.uv[1]*=sY;f.uv_size[0]*=sX;f.uv_size[1]*=sY}});
                }));
                const b=new Blob([JSON.stringify(geo,null,2)],{type:'application/json'}); const a2=document.createElement('a'); a2.href=URL.createObjectURL(b); a2.download='model.geo.json'; setTimeout(()=>a2.click(),500);
            },
            setupCanvasEvents() {
                const w=this.els.canvasWrapper;
                w.addEventListener('wheel',e=>{e.preventDefault();this.state.view.scale=Math.max(0.1,Math.min(this.state.view.scale*(1-e.deltaY*0.001),10));this.renderPreview();});
                w.addEventListener('pointerdown',e=>{this.state.view.dragging=true;this.state.view.lx=e.clientX;this.state.view.ly=e.clientY;});
                window.addEventListener('pointermove',e=>{if(this.state.view.dragging){this.state.view.x+=e.clientX-this.state.view.lx;this.state.view.y+=e.clientY-this.state.view.ly;this.state.view.lx=e.clientX;this.state.view.ly=e.clientY;this.renderPreview();}});
                window.addEventListener('pointerup',()=>this.state.view.dragging=false);
            },
            notify(m,t) { const d=document.createElement('div'); d.className=`px-3 py-2 rounded shadow-lg text-white text-xs ${t==='error'?'bg-red-900':'bg-green-900'} animate-bounce`; d.innerText=m; this.els['toast-container'].appendChild(d); setTimeout(()=>d.remove(),3000); },
            setLoading(s,t) { this.els.loaderText.innerText=t; this.els.loader.style.display=s?'flex':'none'; },
            updateResolution() { this.state.res = parseInt(this.els.resSelect.value); if(this.state.texture) this.synthesize(true); }
        };

        window.app = App;
        window.onload = () => App.init();
    </script>
</body>
</html>